#include "stdafx.h"
#include "MixMgr.h"
#include "./Utilities/Log/ErrorReport.h"
#include "UIManager.h"
#include "ZzzInventory.h"
#include "CSItemOption.h"
#include "UIJewelHarmony.h"
#ifdef ADD_SOCKET_MIX
#include "SocketSystem.h"
#endif	// ADD_SOCKET_MIX

using namespace SEASON3A;

/*+++++++++++++++++++++++++++++++++++++
    FUNCTIONS.
+++++++++++++++++++++++++++++++++++++*/
static BYTE bBuxCode[3] = {0xfc,0xcf,0xab};

static void BuxConvert(BYTE *Buffer,int Size)
{
	for(int i=0;i<Size;i++)
		Buffer[i] ^= bBuxCode[i%3];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CMixRecipeMgr g_MixRecipeMgr;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void CMixItem::Reset()
{
	m_sType = 0;
	m_iLevel = 0;
	m_iOption = 0;
	m_iDurability = 0;
	m_dwSpecialItem = 0;
	m_b380AddedItem = FALSE;
	m_bFenrirAddedItem = FALSE;
	m_bIsCharmItem = FALSE;
#ifdef PSW_ADD_MIX_CHAOSCHARM
	m_bIsChaosCharmItem = FALSE;
#endif //PSW_ADD_MIX_CHAOSCHARM	
#ifdef YDG_FIX_SOCKETSPHERE_MIXRATE
	m_bIsJewelItem = FALSE;
#endif	// YDG_FIX_SOCKETSPHERE_MIXRATE
	m_wHarmonyOption = 0;
	m_wHarmonyOptionLevel = 0;
	m_bMixLuck = FALSE;
	m_bIsEquipment = FALSE;
	m_bIsWing = FALSE;
	m_bIsUpgradedWing = FALSE;
	m_bIs3rdUpgradedWing = FALSE;
#ifdef ADD_SOCKET_MIX
	m_bySocketCount = 0;
	for (int i = 0; i < MAX_SOCKETS; ++i)
	{
		m_bySocketSeedID[i] = SOCKET_EMPTY;
		m_bySocketSphereLv[i] = 0;
	}
#endif	// ADD_SOCKET_MIX
	m_bCanStack = FALSE;
	m_dwMixValue = 0;
	m_iCount = 0;
	m_iTestCount = 0;
}

void CMixItem::SetItem(ITEM * pItem, DWORD dwMixValue)
{
	Reset();
	
	m_sType = pItem->Type;
	m_iLevel = ((pItem->Level>>3) & 15);
	m_iDurability = pItem->Durability;
	for (int i = 0; i < pItem->SpecialNum; i++)
	{
		switch ( pItem->Special[i])
		{
		case AT_IMPROVE_MAGIC:
		case AT_IMPROVE_CURSE:	// 추가 저주력
		case AT_IMPROVE_DAMAGE:
		case AT_IMPROVE_DEFENSE:
		case AT_IMPROVE_BLOCKING:
			m_iOption = pItem->SpecialValue[i];		// 추가 공격력 등 옵션
			break;
		case AT_LIFE_REGENERATION:
			m_iOption = pItem->SpecialValue[i] * 4;		// 생명 자동 회복 옵션 (*4 해서 다른 옵션과 맞춰줌)
			break;
		case AT_LUCK:
			m_bMixLuck = TRUE;						// 행운
			break;
		}
	}
	if ((pItem->Option1 & 63) > 0) m_dwSpecialItem |= RCP_SP_EXCELLENT;	// 엑설런트
	if (pItem->RequireLevel >= 380) m_dwSpecialItem |= RCP_SP_ADD380ITEM;	// 요구 레벨 380 이상인 경우
	if ((pItem->ExtOption % 0x04) == EXT_A_SET_OPTION || (pItem->ExtOption % 0x04) == EXT_B_SET_OPTION) m_dwSpecialItem |= RCP_SP_SETITEM;	// 세트 아이템
	m_b380AddedItem = pItem->option_380;					// 380 옵션이 이미 추가된 아이템인지 여부

	if (pItem->Type >= ITEM_SWORD && pItem->Type <= ITEM_BOOTS+MAX_ITEM_INDEX-1)	// 장비 아이템인지 검사
		m_bIsEquipment = TRUE;

	if (pItem->Type == ITEM_HELPER+37 && pItem->Option1 != 0)
		m_bFenrirAddedItem = TRUE;

	if (pItem->Type == ITEM_POTION+53)	// 행운의 부적인지 검사
		m_bIsCharmItem = TRUE;

#ifdef PSW_ADD_MIX_CHAOSCHARM
	if( pItem->Type == ITEM_POTION+96 )  //  카오스 부적인지 검사
		m_bIsChaosCharmItem = TRUE;
#endif //PSW_ADD_MIX_CHAOSCHARM

#ifdef YDG_FIX_SOCKETSPHERE_MIXRATE
	if(pItem->Type == ITEM_WING+15		// 혼돈의보석
		|| pItem->Type == ITEM_WING+30		// 축복의보석 묶음
		|| pItem->Type == ITEM_WING+31		// 영혼의보석 묶음
		|| pItem->Type == ITEM_POTION+13	// 축복의보석
		|| pItem->Type == ITEM_POTION+14	// 영혼의보석
		|| pItem->Type == ITEM_POTION+16	// 생명의보석
		|| pItem->Type == ITEM_POTION+22	// 창조의보석
		|| pItem->Type == ITEM_POTION+31	// 수호보석
		|| pItem->Type == ITEM_POTION+42	// 조화의보석
		)	// 보석 아이템인지 검사 (축,영,혼,창,생,조,수,석묶음)
		m_bIsJewelItem = TRUE;
#endif	// YDG_FIX_SOCKETSPHERE_MIXRATE

#ifdef ADD_SOCKET_MIX
	m_bySocketCount = pItem->SocketCount;
	if (m_bySocketCount > 0)	// 소켓 아이템인지 검사
	{
		m_dwSpecialItem |= RCP_SP_SOCKETITEM;
		for (int i = 0; i < MAX_SOCKETS; ++i)
		{
			m_bySocketSeedID[i] = pItem->SocketSeedID[i];
			m_bySocketSphereLv[i] = pItem->SocketSphereLv[i];
		}
#ifdef YDG_FIX_SOCKETITEM_ISNOT_380ITEM
		m_dwSpecialItem ^= RCP_SP_ADD380ITEM;	// 소켓아이템은 380 아이템이 아니다
#endif	// YDG_FIX_SOCKETITEM_ISNOT_380ITEM
	}
	m_bySeedSphereID = g_SocketItemMgr.GetSeedShpereSeedID(pItem);
#endif	// ADD_SOCKET_MIX

	if (pItem->Jewel_Of_Harmony_Option > 0)
	{
		m_dwSpecialItem |= RCP_SP_HARMONY;	// 조화의 보석 제련된 아이템
		m_wHarmonyOption = pItem->Jewel_Of_Harmony_Option;
		m_wHarmonyOptionLevel = pItem->Jewel_Of_Harmony_OptionLevel;
	}

	switch(pItem->Type)		// 날개인지 검사
	{
	case ITEM_WING:			// 요정날개
	case ITEM_WING+1:		// 천공날개
	case ITEM_WING+2:		// 사탄날개
#ifdef ADD_ALICE_WINGS_1
	case ITEM_WING+41:		// 재앙의날개
#endif	// ADD_ALICE_WINGS_1
		m_bIsWing = TRUE;
		break;
	case ITEM_WING+3:		// 정령날개
	case ITEM_WING+4:		// 영혼날개
	case ITEM_WING+5:		// 드라곤날개
	case ITEM_WING+6:		// 암흑날개
	case ITEM_HELPER+30:	// 군주의 망토
#ifdef ADD_ALICE_WINGS_1
	case ITEM_WING+42:		// 절망의날개
#endif	// ADD_ALICE_WINGS_1
#ifdef PBG_ADD_NEWCHAR_MONK_ITEM
	case ITEM_WING+49:		// 무인의망토
#endif //PBG_ADD_NEWCHAR_MONK_ITEM
		m_bIsUpgradedWing = TRUE;
		break;
	case ITEM_WING+36:		// 폭풍의날개
	case ITEM_WING+37:		// 시공의날개
	case ITEM_WING+38:		// 환영의날개
	case ITEM_WING+39:		// 파멸의날개
	case ITEM_WING+40:		// 제왕의망토
#ifdef ADD_ALICE_WINGS_1
	case ITEM_WING+43:		// 차원의날개
#endif	// ADD_ALICE_WINGS_1
#ifdef PBG_ADD_NEWCHAR_MONK_ITEM
	case ITEM_WING+50:		//군림의망토
#endif //PBG_ADD_NEWCHAR_MONK_ITEM
		m_bIs3rdUpgradedWing = TRUE;
	}
#ifdef YDG_FIX_WING_MIX_RATE
	if (m_bIsWing || m_bIsUpgradedWing || m_bIs3rdUpgradedWing)
	{
		if (m_dwSpecialItem & RCP_SP_EXCELLENT)
			m_dwSpecialItem ^= RCP_SP_EXCELLENT;	// 날개는 엑템 제외
	}
#endif	// YDG_FIX_WING_MIX_RATE
	switch(pItem->Type)		// 포개기 가능한 아이템인지 검사
	{
	case ITEM_POTION+3:		// 큰치료물약
	case ITEM_POTION+38:	// 작은 복합물약
	case ITEM_POTION+39:	// 중간 복합물약
	case ITEM_POTION+53:	// 행운의 부적
#ifdef CSK_EVENT_CHERRYBLOSSOM
	case ITEM_POTION+88:	// 하얀 벚꽃가지
	case ITEM_POTION+89:	// 붉은 벚꽃가지
	case ITEM_POTION+90:	// 황금 벚꽃가지
#endif	// CSK_EVENT_CHERRYBLOSSOM
#ifdef KJH_PBG_ADD_SEVEN_EVENT_2008
	case ITEM_POTION+100:	//행운의 동전
#endif //KJH_PBG_ADD_SEVEN_EVENT_2008
		m_bCanStack = TRUE;
		break;
	}
	m_dwMixValue = dwMixValue;

	if (m_bCanStack == TRUE) m_iCount = m_iDurability;
	else m_iCount = 1;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int CMixItemInventory::AddItem(ITEM * pItem)
{
//#define PJH_REPAIR_MIX  
#ifdef PJH_REPAIR_MIX
	BOOL bFind = TRUE;
#else
	BOOL bFind = FALSE;
#endif

	for (int i = 0; i < m_iNumMixItems; ++i)
	{
		if (m_MixItems[i] == pItem)	// 중복 아이템
		{
			bFind = TRUE;
			m_MixItems[i].m_dwMixValue += EvaluateMixItemValue(pItem);
			if (m_MixItems[i].m_bCanStack == TRUE)
			{
				m_MixItems[i].m_iCount += pItem->Durability;
			}
			else
			{
				++m_MixItems[i].m_iCount;
			}
			break;
		}
	}
	if (bFind == FALSE)
	{
		// 아이템 추가
		m_MixItems[m_iNumMixItems++].SetItem(pItem, EvaluateMixItemValue(pItem));
	}

	return 0;
}

DWORD CMixItemInventory::EvaluateMixItemValue(ITEM * pItem)
{
	DWORD dwMixValue = 0;
	switch (pItem->Type)
	{
	case ITEM_WING+15:		// 혼석
		dwMixValue = 40000;	//  810000
		break;
	case ITEM_POTION+13:	// 축석
		dwMixValue = 100000;	//  9000000
		break;
	case ITEM_POTION+14:	// 영석
		dwMixValue = 70000;	//  6000000
		break;
	case ITEM_POTION+22:	// 창석
		dwMixValue = 450000;	//  36000000
		break;
	case ITEM_POTION+16:	// 생명의 보석
		dwMixValue = 0;
		break;
	case ITEM_POTION+31:	//  수호보석.
	default:
		dwMixValue = ItemValue(pItem, 0);
		break;
	}
	return dwMixValue;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void CMixRecipes::Reset()
{
	ClearCheckRecipeResult();
	std::vector<MIX_RECIPE *>::iterator iter;
	for (iter = m_Recipes.begin(); iter != m_Recipes.end(); ++iter)
	{
		if (*iter != NULL)
		{
			delete *iter;
			*iter = NULL;
		}
	}
	m_Recipes.clear();
}

void CMixRecipes::AddRecipe(MIX_RECIPE * pMixRecipe)
{
	if (pMixRecipe != NULL)
		m_Recipes.push_back(pMixRecipe);
}

BOOL CMixRecipes::IsMixSource(ITEM * pItem)
{
	CMixItem mixitem;
	mixitem.SetItem(pItem, 0);

#ifdef LEM_ADD_LUCKYITEM	// 럭키아이템 환원만 되게 [lem_2010.9.8]
	if( Check_LuckyItem( pItem->Type ) && g_MixRecipeMgr.GetMixInventoryType() != MIXTYPE_JERRIDON )	return FALSE;
#endif // LEM_ADD_LUCKYITEM

	if (IsCharmItem(mixitem))		// 행운의 부적 아이템
	{
		if ((GetCurRecipe() == NULL || GetCurRecipe()->m_bCharmOption == 'A')
			&& m_wTotalCharmBonus + mixitem.m_iCount <= 10)	// 행운의 부적 확률은 최대 10%로 제한한다
		{
			return TRUE;
		}
	}

#ifdef PSW_ADD_MIX_CHAOSCHARM
	if( IsChaosCharmItem(mixitem)) {
		if ((GetCurRecipe() == NULL || GetCurRecipe()->m_bCharmOption == 'A')
			&& m_wTotalChaosCharmCount < 1) 
		{
			return TRUE;
		}
	}
#endif //PSW_ADD_MIX_CHAOSCHARM

	for (std::vector<MIX_RECIPE *>::iterator iter = m_Recipes.begin(); iter != m_Recipes.end(); ++iter)
	{
		// 조합 방법의 각 상황을 기준으로 비교
		for (int j = 0; j < (*iter)->m_iNumMixSoruces; ++j)
		{
			if (m_wTotalCharmBonus > 0 && (*iter)->m_bCharmOption != 'A')
			{
				continue;	// 행운의 부적이 올라가 있을때는 행운의 부적 사용불가 조합을 할 수 없다.
			}
			if (CheckItem((*iter)->m_MixSources[j], mixitem)
				&& !((*iter)->m_bMixOption == 'B' && IsChaosItem(mixitem))
				&& !((*iter)->m_bMixOption == 'C' && Is380AddedItem(mixitem))
				&& !((*iter)->m_bMixOption == 'D' && IsFenrirAddedItem(mixitem))
				&& !((*iter)->m_bMixOption == 'E' && !IsUpgradableItem(mixitem))
				&& !((*iter)->m_bMixOption == 'G' && !IsSourceOfRefiningStone(mixitem))
				)	// 조합 방법 재료중 하나라도 포함되나
			{
				return TRUE;
			}
		}
	}
	return FALSE;
}

void CMixRecipes::ClearCheckRecipeResult()
{
	m_iCurMixIndex = 0;
	m_iMostSimilarMixIndex = 0;
	m_iSuccessRate = 0;
	m_dwRequiredZen = 0;
	m_bFindMixLuckItem = FALSE;
	m_dwTotalItemValue = 0;
	m_dwExcellentItemValue = 0;
	m_dwEquipmentItemValue = 0;
	m_dwWingItemValue = 0;
	m_dwSetItemValue = 0;
	m_iFirstItemLevel = 0;
	m_iFirstItemType = 0;
#ifdef YDG_FIX_SOCKETSPHERE_MIXRATE
	m_dwTotalNonJewelItemValue = 0;
#endif	// YDG_FIX_SOCKETSPHERE_MIXRATE
#ifdef ADD_SOCKET_MIX
	m_byFirstItemSocketCount = 0;
	for (int i = 0; i < MAX_SOCKETS; ++i)
	{
		m_byFirstItemSocketSeedID[i] = SOCKET_EMPTY;
		m_byFirstItemSocketSphereLv[i] = 0;
	}
#endif	// ADD_SOCKET_MIX
	m_wTotalCharmBonus = 0;
}

int CMixRecipes::CheckRecipe(int iNumMixItems, CMixItem * pMixItems)	// 아이템 인벤 정보와 조합 방법을 비교하여 결과 반환
{
	m_iCurMixIndex = 0;

#ifdef ADD_SOCKET_MIX
#ifdef KJW_FIX_SOCKET_INFORMATION
	m_byFirstItemSocketCount = 0;
#endif // KJW_FIX_SOCKET_INFORMATION
#endif	// ADD_SOCKET_MIX

	std::vector<MIX_RECIPE *>::iterator iter;
	for (iter = m_Recipes.begin(); iter != m_Recipes.end(); ++iter)
	{
		for (int i = 0; i < iNumMixItems; ++i)
		{
			pMixItems[i].m_iTestCount = pMixItems[i].m_iCount;	// 검사용 카운트 변수를 초기화
		}
		if (CheckRecipeSub(iter, iNumMixItems, pMixItems) == TRUE)	// 조합 성공
		{
			m_iCurMixIndex = (*iter)->m_iMixIndex + 1;
			EvaluateMixItems(iNumMixItems, pMixItems);
			CalcCharmBonusRate(iNumMixItems, pMixItems);
			CalcMixRate(iNumMixItems, pMixItems);	// 조합 성공 확률 계산
			CalcMixReqZen(iNumMixItems, pMixItems);	// 조합 필요 젠 계산
			return GetCurRecipe()->m_iMixID;	    // 조합 번호를 반환해야한다
		}
		else
		{
			m_iSuccessRate = 0;
			m_dwRequiredZen = 0;
		}
	}
	return (-1);
}

BOOL CMixRecipes::CheckRecipeSub(std::vector<MIX_RECIPE *>::iterator iter, int iNumMixItems, CMixItem * pMixItems)
{
	BOOL bFind = FALSE;
	int iMixRecipeTest[MAX_MIX_SOURCES];	// 조합 재료별로 아이템 일치 수
	memset(iMixRecipeTest, 0, sizeof(int) * MAX_MIX_SOURCES);

#ifdef ADD_SOCKET_MIX
#ifndef KJW_FIX_SOCKET_INFORMATION
	m_byFirstItemSocketCount = 0;
#endif // KJW_FIX_SOCKET_INFORMATION
#endif	// ADD_SOCKET_MIX

	// 조합 방법의 각 상황을 기준으로 인벤을 뒤져 같은게 없으면 실패, 있으면 인벤에서 지우고 계속 비교한다
	for (int j = 0; j < (*iter)->m_iNumMixSoruces; ++j)
	{
		if (!IsOptionItem((*iter)->m_MixSources[j])) bFind = FALSE;
		for (int i = 0; i < iNumMixItems; ++i)
		{
			// 재료가 일치하고, 잔량이 있고, 현재 조합 재료별 일치수와 이 재료의 잔량이 최대 재료수보다 적을경우에
			if (CheckItem((*iter)->m_MixSources[j], pMixItems[i]) && pMixItems[i].m_iTestCount > 0 &&
				(*iter)->m_MixSources[j].m_iCountMax >= iMixRecipeTest[j] + pMixItems[i].m_iTestCount
#ifdef YDG_FIX_SOCKET_ATTACH_CONDITION
				&& !((*iter)->m_bMixOption == 'H' && IsSourceOfAttachSeedSphereToArmor(pMixItems[i]))	// 소켓장착시 스피어종류 제한
				&& !((*iter)->m_bMixOption == 'I' && IsSourceOfAttachSeedSphereToWeapon(pMixItems[i]))
#endif	// YDG_FIX_SOCKET_ATTACH_CONDITION
				)
			{
				if (pMixItems[i].m_iTestCount >= (*iter)->m_MixSources[j].m_iCountMax)
				{
					iMixRecipeTest[j] += (*iter)->m_MixSources[j].m_iCountMax;
					pMixItems[i].m_iTestCount -= (*iter)->m_MixSources[j].m_iCountMax;	// 최대치만큼 있으면 최대치를 빼준다.
				}
				else
				{
					iMixRecipeTest[j] += pMixItems[i].m_iTestCount;
					pMixItems[i].m_iTestCount = 0;	// 아니면 있는만큼 다 빼낸다.
				}
				bFind = TRUE;	// 아이템을 찾았다
				if (j == 0)
				{
					m_iFirstItemLevel = pMixItems[i].m_iLevel;	// 첫번째 아이템이면 아이템의 레벨 저장
					m_iFirstItemType = pMixItems[i].m_sType;
#ifdef ADD_SOCKET_MIX
					m_byFirstItemSocketCount = pMixItems[i].m_bySocketCount;	// 첫번째 아이템이면 소켓 정보 저장
					if (m_byFirstItemSocketCount > 0)
					{
						for (int k = 0; k < MAX_SOCKETS; ++k)
						{
							m_byFirstItemSocketSeedID[k] = pMixItems[i].m_bySocketSeedID[k];
							m_byFirstItemSocketSphereLv[k] = pMixItems[i].m_bySocketSphereLv[k];
						}
					}
#endif	// ADD_SOCKET_MIX
				}
			}
		}
		if (bFind == FALSE || (*iter)->m_MixSources[j].m_iCountMin > iMixRecipeTest[j])		// 필요한 아이템을 못찾거나 재료가 모자르면 실패
		{
			return FALSE;
		}
	}
	// 남은 재료가 있으면 안된다.
	for (int i = 0; i < iNumMixItems; ++i)
	{
		if (pMixItems[i].m_iTestCount > 0)
		{
			if (pMixItems[i].m_bIsCharmItem && (*iter)->m_bCharmOption == 'A');	// 행운의 부적은 있어도 상관없다.
			else
#ifdef PSW_ADD_MIX_CHAOSCHARM
			if(pMixItems[i].m_bIsChaosCharmItem && (*iter)->m_bChaosCharmOption == 'A'); // 카오스 부적은 있어도 상관없다.
			else
#endif //PSW_ADD_MIX_CHAOSCHARM
				return FALSE;	// 해당 조합에 필요없는 아이템이 있다.
		}
	}
	return TRUE;	// 아이템이 정확하게 존재한다.
}

int CMixRecipes::CheckRecipeSimilarity(int iNumMixItems, CMixItem * pMixItems)
{
	if (iNumMixItems == 0 && m_Recipes.size() == 1)	// 조합 방법이 하나뿐일때는 아이템을 올리지 않아도 무조건 보여준다.
	{
		m_iMostSimilarMixIndex = 1;
		for (int i = 0; i < (*m_Recipes.begin())->m_iNumMixSoruces; ++i)
		{
			m_iMostSimilarMixSourceTest[i] = (*m_Recipes.begin())->m_MixSources[0].m_iCountMax;
		}
		return m_iMostSimilarMixIndex;
	}

	int iMostSimiliarRecipe = 0;	// 가장 유사한 조합법 인덱스
	int iMostSimiliarityPoint = 0;	// 가장 유사한 조합법 유사도 점수
	memset(m_iMostSimilarMixSourceTest, 0, sizeof(int) * MAX_MIX_SOURCES);
	memset(m_iMixSourceTest, 0, sizeof(int) * MAX_MIX_SOURCES);

	int iSimilarityPoint;			// 유사도 점수
	for (std::vector<MIX_RECIPE *>::iterator iter = m_Recipes.begin(); iter != m_Recipes.end(); ++iter)
	{
		memset(m_iMixSourceTest, 0, sizeof(int) * MAX_MIX_SOURCES);
		for (int i = 0; i < (*iter)->m_iNumMixSoruces; ++i)
			m_iMixSourceTest[i] = (*iter)->m_MixSources[i].m_iCountMax;	// 조합법 충족 검사용 카운트 변수를 초기화
#ifdef _VS2008PORTING
		for (int i = 0; i < iNumMixItems; ++i)
#else // _VS2008PORTING
		for (i = 0; i < iNumMixItems; ++i)
#endif // _VS2008PORTING
			pMixItems[i].m_iTestCount = pMixItems[i].m_iCount;	// 검사용 카운트 변수를 초기화

		iSimilarityPoint = CheckRecipeSimilaritySub(iter, iNumMixItems, pMixItems);
		if (iSimilarityPoint == 1 && m_Recipes.size() > 1) iSimilarityPoint = 0;	// 혼석만 있는경우 무시
		if (iSimilarityPoint > iMostSimiliarityPoint ||
			(iSimilarityPoint == iMostSimiliarityPoint && iSimilarityPoint > 0 && m_iCurMixIndex == (*iter)->m_iMixIndex + 1))
		{
			// 잘못된 아이템이 있으면 무시해야한다.
			iMostSimiliarityPoint = iSimilarityPoint;
			iMostSimiliarRecipe = (*iter)->m_iMixIndex + 1;
			memset(m_iMostSimilarMixSourceTest, 0, sizeof(int) * MAX_MIX_SOURCES);
			for (int i = 0; i < (*iter)->m_iNumMixSoruces; ++i)
			{
				m_iMostSimilarMixSourceTest[i] = m_iMixSourceTest[i];
			}
		}
	}
	m_iMostSimilarMixIndex = iMostSimiliarRecipe;
	return iMostSimiliarRecipe;
}

int CMixRecipes::CheckRecipeSimilaritySub(std::vector<MIX_RECIPE *>::iterator iter, int iNumMixItems, CMixItem * pMixItems)
{
	int iFindTotalPoint = 0;
	int iFindPoint = 0;
	// 조합 방법의 각 상황을 기준으로 인벤을 뒤져 같은게 있으면 유사도 반환
	for (int j = 0; j < (*iter)->m_iNumMixSoruces; ++j)
	{
		for (int i = 0; i < iNumMixItems; ++i)
		{
			if (CheckItem((*iter)->m_MixSources[j], pMixItems[i]) && pMixItems[i].m_iTestCount > 0
#ifdef YDG_FIX_SOCKET_ATTACH_CONDITION
				&& !((*iter)->m_bMixOption == 'H' && IsSourceOfAttachSeedSphereToArmor(pMixItems[i]))	// 소켓장착시 스피어종류 제한
				&& !((*iter)->m_bMixOption == 'I' && IsSourceOfAttachSeedSphereToWeapon(pMixItems[i]))
#endif	// YDG_FIX_SOCKET_ATTACH_CONDITION
				)	// 조합 방법
			{
				if (IsChaosJewel(pMixItems[i])) iFindPoint = 1;	// 혼석은 1점
 				else if ((*iter)->m_MixSources[j].m_iCountMax < pMixItems[i].m_iTestCount) iFindPoint = 1;	// 갯수가 조합법보다 많으면 0점
				else if (j == 0) iFindPoint = 10;	// 첫번째가 일치하면 유사도 보너스 10점
				else if (j == 1) iFindPoint = 5;	// 두번째가 일치하면 유사도 보너스 5점
				//else if (IsOptionItem((*iter)->m_MixSources[j])) iFindPoint = 2;	// 옵션 아이템은 0점
				else iFindPoint = 3;	// 나머지는 2점

				iFindTotalPoint += iFindPoint;

 				if (pMixItems[i].m_iTestCount > 0 && m_iMixSourceTest[j] > 0)
				{
					m_iMixSourceTest[j] -= pMixItems[i].m_iTestCount;
					pMixItems[i].m_iTestCount -= (*iter)->m_MixSources[j].m_iCountMax;	// 최대치를 빼준다.
				}
			}
		}
	}
	for (int i = 0; i < iNumMixItems; ++i)
	{
		if (pMixItems[i].m_iTestCount > 0)
		{
			if (pMixItems[i].m_bIsCharmItem && (*iter)->m_bCharmOption == 'A');	// 행운의 부적은 있어도 상관없다.
			else
#ifdef PSW_ADD_MIX_CHAOSCHARM
			if (pMixItems[i].m_bIsChaosCharmItem && (*iter)->m_bChaosCharmOption == 'A'); // 카오스 부적은 있어도 상관없다.
			else
#endif //PSW_ADD_MIX_CHAOSCHARM
				return 0;	// 해당 조합에 필요없는 아이템이 있다.
		}
	}
	return iFindTotalPoint;
}

bool CMixRecipes::CheckItem(MIX_RECIPE_ITEM & rItem, CMixItem & rSource)
{
	if (rItem.m_sTypeMin <= rSource.m_sType && rItem.m_sTypeMax >= rSource.m_sType &&
		rItem.m_iLevelMin <= rSource.m_iLevel && rItem.m_iLevelMax >= rSource.m_iLevel &&
		rItem.m_iDurabilityMin <= rSource.m_iDurability && rItem.m_iDurabilityMax >= rSource.m_iDurability &&
		rItem.m_iOptionMin <= rSource.m_iOption && rItem.m_iOptionMax >= rSource.m_iOption &&
		(rItem.m_dwSpecialItem & RCP_SP_EXCELLENT) <= (rSource.m_dwSpecialItem & RCP_SP_EXCELLENT) &&
		(rItem.m_dwSpecialItem & RCP_SP_ADD380ITEM) <= (rSource.m_dwSpecialItem & RCP_SP_ADD380ITEM) &&
		(rItem.m_dwSpecialItem & RCP_SP_SETITEM) <= (rSource.m_dwSpecialItem & RCP_SP_SETITEM)
		&& (rItem.m_dwSpecialItem & RCP_SP_HARMONY) <= (rSource.m_dwSpecialItem & RCP_SP_HARMONY)
#ifdef ADD_SOCKET_MIX
		&& (rItem.m_dwSpecialItem & RCP_SP_SOCKETITEM) <= (rSource.m_dwSpecialItem & RCP_SP_SOCKETITEM)
#endif	// ADD_SOCKET_MIX
		)
	{
		return true;
	}
	return false;
}

MIX_RECIPE * CMixRecipes::GetCurRecipe()
{
	if (m_iCurMixIndex == 0) return NULL;
	return m_Recipes[m_iCurMixIndex - 1];
}

MIX_RECIPE * CMixRecipes::GetMostSimilarRecipe()
{
	if (m_iMostSimilarMixIndex == 0) return NULL;
	return m_Recipes[m_iMostSimilarMixIndex - 1];
}

int CMixRecipes::GetCurMixID()
{
	if (m_iCurMixIndex == 0) return 0;
	return m_Recipes[m_iCurMixIndex - 1]->m_iMixID;
}

BOOL CMixRecipes::GetCurRecipeName(unicode::t_char * pszNameOut, int iNameLine)
{
	if (!IsReadyToMix())
	{
		if (iNameLine == 1)
		{
			switch(g_MixRecipeMgr.GetMixInventoryType())
			{
			case MIXTYPE_TRAINER:
				unicode::_sprintf (pszNameOut, GlobalText[1213], GlobalText[1212]);	// 부활용 아이템 부적합
				break;
			case MIXTYPE_OSBOURNE:
				unicode::_sprintf (pszNameOut, GlobalText[1213], GlobalText[2061]);	// 제련용 아이템 부적합
				break;
			case MIXTYPE_JERRIDON:
				unicode::_sprintf (pszNameOut, GlobalText[1213], GlobalText[2062]);	// 제련용 아이템 부적합
				break;
			case MIXTYPE_ELPIS:
				unicode::_sprintf (pszNameOut, GlobalText[1213], GlobalText[2063]);	// 정제용 아이템 부적합
				break;
			default:
				unicode::_sprintf (pszNameOut, "%s", GlobalText[601]);
				break;
			}
			return TRUE;
		}
		else return FALSE;
	}
	return GetRecipeName(GetCurRecipe(), pszNameOut, iNameLine, FALSE);
}

BOOL CMixRecipes::GetRecipeName(MIX_RECIPE * pRecipe, unicode::t_char * pszNameOut, int iNameLine, BOOL bSimilarRecipe)
{
	if (pRecipe == NULL) return FALSE;
	if (iNameLine > 2 || iNameLine < 1) return FALSE;
	if (pRecipe->m_bMixOption == 'C')	// 380 옵션
	{
		vector<std::string> optionTextlist;
		// 380아이템의 타입에 따라 다른 옵션이 붙는다.
		g_pItemAddOptioninfo->GetItemAddOtioninfoText(optionTextlist, m_iFirstItemType);
		if (optionTextlist.empty() || bSimilarRecipe)
		{
			if (iNameLine == 1)
			{
				unicode::_sprintf (pszNameOut, "%s", GlobalText[2194]);
				return TRUE;
			}
			return FALSE;
		}
		assert(optionTextlist.size() == 2 && "옵션은 2개여야 함");
		if (iNameLine == 1)
		{
			unicode::_strcpy(pszNameOut, optionTextlist[0].c_str());
			return TRUE;
		}
		else if (iNameLine == 2)
		{
			unicode::_strcpy(pszNameOut, optionTextlist[1].c_str());
			return TRUE;
		}
		return FALSE;
	}
	else
	{
		if (iNameLine == 1)
		{
			if (pRecipe->m_iMixName[1] == 0)
				unicode::_sprintf (pszNameOut, "%s", GlobalText[pRecipe->m_iMixName[0]]);
			else if (pRecipe->m_iMixName[2] == 0)
				unicode::_sprintf (pszNameOut, "%s %s", GlobalText[pRecipe->m_iMixName[0]], GlobalText[pRecipe->m_iMixName[1]]);
			else
				unicode::_sprintf (pszNameOut, "%s %s %s", GlobalText[pRecipe->m_iMixName[0]],
					GlobalText[pRecipe->m_iMixName[1]], GlobalText[pRecipe->m_iMixName[2]]);
			return TRUE;
		}
		return FALSE;
	}
}

BOOL CMixRecipes::GetCurRecipeDesc(unicode::t_char * pszDescOut, int iDescLine)
{
	if (iDescLine > 3 || iDescLine < 1) return FALSE;
	if (GetCurRecipe() == NULL) return FALSE;
	if (GetCurRecipe()->m_iMixDesc[iDescLine - 1] > 0)
		unicode::_strcpy(pszDescOut, GlobalText[GetCurRecipe()->m_iMixDesc[iDescLine - 1]]);
	else
		return FALSE;
	return TRUE;
}

BOOL CMixRecipes::GetMostSimilarRecipeName(unicode::t_char * pszNameOut, int iNameLine)
{
	return GetRecipeName(GetMostSimilarRecipe(), pszNameOut, iNameLine, TRUE);
}

BOOL CMixRecipes::GetRecipeAdvice(unicode::t_char * pszAdviceOut, int iAdivceLine)
{
	if (GetMostSimilarRecipe() == NULL) return FALSE;
	if (iAdivceLine > 3 || iAdivceLine < 1) return FALSE;

	if (GetMostSimilarRecipe()->m_iMixAdvice[iAdivceLine - 1] > 0)
		unicode::_strcpy(pszAdviceOut, GlobalText[GetMostSimilarRecipe()->m_iMixAdvice[iAdivceLine - 1]]);
	else
		return FALSE;
	return TRUE;
}

int CMixRecipes::GetSourceName(int iItemNum, unicode::t_char * pszNameOut, int iNumMixItems, CMixItem * pMixItems)
{
#ifdef KWAK_FIX_COMPILE_LEVEL4_WARNING
	if(iNumMixItems < 0)	return MIX_SOURCE_ERROR;
	if(pMixItems == NULL)	return MIX_SOURCE_ERROR;
#endif // KWAK_FIX_COMPILE_LEVEL4_WARNING
	if (GetMostSimilarRecipe() == NULL) return MIX_SOURCE_ERROR;
	if (iItemNum >= GetMostSimilarRecipe()->m_iNumMixSoruces) return MIX_SOURCE_ERROR;

	MIX_RECIPE_ITEM * pMixRecipeItem = &GetMostSimilarRecipe()->m_MixSources[iItemNum];

	unicode::t_char szTempName[100];
	GetItemName(pMixRecipeItem->m_sTypeMin, pMixRecipeItem->m_iLevelMin, szTempName);

	// 고정 이름 아이템
 	if (pMixRecipeItem->m_sTypeMin == pMixRecipeItem->m_sTypeMax &&
		(pMixRecipeItem->m_iLevelMin == pMixRecipeItem->m_iLevelMax || (pMixRecipeItem->m_iLevelMin == 0 && pMixRecipeItem->m_iLevelMax == 255)) &&
		(pMixRecipeItem->m_iOptionMin == pMixRecipeItem->m_iOptionMax || (pMixRecipeItem->m_iOptionMin == 0 && pMixRecipeItem->m_iOptionMax == 255)))
	{
		// 아이템 내구도
		if (pMixRecipeItem->m_iDurabilityMin == pMixRecipeItem->m_iDurabilityMax)
			unicode::_sprintf(szTempName, "%s(%d)", szTempName, pMixRecipeItem->m_iDurabilityMin);
	}
	else	// 구간 이름 아이템
	{
		// 아이템 이름
		if (pMixRecipeItem->m_dwSpecialItem & RCP_SP_ADD380ITEM)
			unicode::_sprintf(szTempName, GlobalText[2335]);	// "380레벨 아이템"
		else if (pMixRecipeItem->m_sTypeMin == 0 && pMixRecipeItem->m_sTypeMax == ITEM_BOOTS+MAX_ITEM_INDEX-1)
			unicode::_sprintf(szTempName, GlobalText[2336]);	// "장비아이템"
		else if (pMixRecipeItem->m_sTypeMin == 0 && pMixRecipeItem->m_sTypeMax == ITEM_HELPER+MAX_ITEM_INDEX-1)
			unicode::_sprintf(szTempName, GlobalText[2336]);	// "장비아이템" 날개포함
		else if (pMixRecipeItem->m_sTypeMin == 0 && pMixRecipeItem->m_sTypeMax == ITEM_STAFF+MAX_ITEM_INDEX-1)
			unicode::_sprintf(szTempName, GlobalText[2337]);	// "무기아이템"
		else if (pMixRecipeItem->m_sTypeMin == ITEM_SHIELD && pMixRecipeItem->m_sTypeMax == ITEM_BOOTS+MAX_ITEM_INDEX-1)
			unicode::_sprintf(szTempName, GlobalText[2338]);	// "방어아이템"
		else if (pMixRecipeItem->m_sTypeMin == ITEM_WING && pMixRecipeItem->m_sTypeMax == ITEM_WING+2)
			unicode::_sprintf(szTempName, GlobalText[2339]);	// "1차날개"
		else if (pMixRecipeItem->m_sTypeMin == ITEM_WING+3 && pMixRecipeItem->m_sTypeMax == ITEM_WING+6)
			unicode::_sprintf(szTempName, GlobalText[2348]);	// "2차날개"
#ifdef ADD_ALICE_WINGS_1
		else if (pMixRecipeItem->m_sTypeMin == ITEM_WING+41 && pMixRecipeItem->m_sTypeMax == ITEM_WING+41)
			unicode::_sprintf(szTempName, GlobalText[2339]);	// "1차날개"
		else if (pMixRecipeItem->m_sTypeMin == ITEM_WING+42 && pMixRecipeItem->m_sTypeMax == ITEM_WING+42)
			unicode::_sprintf(szTempName, GlobalText[2348]);	// "2차날개"
#endif	// ADD_ALICE_WINGS_1
		else if (pMixRecipeItem->m_sTypeMin == pMixRecipeItem->m_sTypeMax &&
			(pMixRecipeItem->m_sTypeMin == ITEM_MACE+6 || pMixRecipeItem->m_sTypeMin == ITEM_BOW+6 || pMixRecipeItem->m_sTypeMin == ITEM_STAFF+7))
			unicode::_sprintf(szTempName, GlobalText[2340]);	// "카오스무기"
#ifdef ADD_SOCKET_MIX
		else if (pMixRecipeItem->m_sTypeMin == ITEM_WING+60 && pMixRecipeItem->m_sTypeMax == ITEM_WING+65)
			unicode::_sprintf(szTempName, GlobalText[2680]);	// "시드"
		else if (pMixRecipeItem->m_sTypeMin == ITEM_WING+70 && pMixRecipeItem->m_sTypeMax == ITEM_WING+74)
			unicode::_sprintf(szTempName, GlobalText[2681]);	// "스피어"
		else if (pMixRecipeItem->m_sTypeMin == ITEM_WING+100 && pMixRecipeItem->m_sTypeMax == ITEM_WING+129)
			unicode::_sprintf(szTempName, GlobalText[2682]);	// "시드 스피어"
#ifdef YDG_FIX_SOCKET_ATTACH_CONDITION
		else if (pMixRecipeItem->m_sTypeMin == ITEM_WING+100 && pMixRecipeItem->m_sTypeMax == ITEM_WING+128)
			unicode::_sprintf(szTempName, "%s (%s)", GlobalText[2682], GlobalText[2684]);	// "시드 스피어 (불,얼음,번개)"
		else if (pMixRecipeItem->m_sTypeMin == ITEM_WING+101 && pMixRecipeItem->m_sTypeMax == ITEM_WING+129)
			unicode::_sprintf(szTempName, "%s (%s)", GlobalText[2682], GlobalText[2685]);	// "시드 스피어 (물,바람)"
#endif	// YDG_FIX_SOCKET_ATTACH_CONDITION
#endif	// ADD_SOCKET_MIX
		else
		{
			// 이름만 뜯어낸다
			int iNameLen = unicode::_strlen(szTempName);
			for (int j = 1; j <= 3 && iNameLen - j - 1 >= 0; ++j)
				if (szTempName[iNameLen - j] == '+') szTempName[iNameLen - j - 1] = '\0';	// 레벨 잘라버림
		}
		// 아이템 내구도
		if (pMixRecipeItem->m_iDurabilityMin == pMixRecipeItem->m_iDurabilityMax)
			unicode::_sprintf(szTempName, "%s(%d)", szTempName, pMixRecipeItem->m_iDurabilityMin);
		// 아이템 레벨
		if (pMixRecipeItem->m_iLevelMin == 0 && pMixRecipeItem->m_iLevelMax == 255);	// 모든 레벨 가능
		else if (pMixRecipeItem->m_iLevelMin == pMixRecipeItem->m_iLevelMax)	// 일정 레벨
			unicode::_sprintf(szTempName, "%s +%d", szTempName, pMixRecipeItem->m_iLevelMin);
		else if (pMixRecipeItem->m_iLevelMin == 0)	// max레벨 이하
			unicode::_sprintf(szTempName, "%s +%d%s", szTempName, pMixRecipeItem->m_iLevelMax, GlobalText[2342]);	// "이하"
		else if (pMixRecipeItem->m_iLevelMax == 255)	// min레벨 이상
			unicode::_sprintf(szTempName, "%s +%d%s", szTempName, pMixRecipeItem->m_iLevelMin, GlobalText[2341]);	// "이상"
		else
			unicode::_sprintf(szTempName, "%s +%d~%d", szTempName, pMixRecipeItem->m_iLevelMin, pMixRecipeItem->m_iLevelMax);
		// 아이템 옵션
		if (pMixRecipeItem->m_iOptionMin == 0 && pMixRecipeItem->m_iOptionMax == 255);	// 모든 옵션 가능
		else if (pMixRecipeItem->m_iOptionMin == pMixRecipeItem->m_iOptionMax)	// 일정 옵션
			unicode::_sprintf(szTempName, "%s +%d%s", szTempName, pMixRecipeItem->m_iOptionMin, GlobalText[2343]);	// "옵션"
		else if (pMixRecipeItem->m_iOptionMin == 0)	// max옵션 이하
			unicode::_sprintf(szTempName, "%s +%d%s%s", szTempName, pMixRecipeItem->m_iOptionMax, GlobalText[2343], GlobalText[2342]);	// "옵션""이하"
		else if (pMixRecipeItem->m_iOptionMax == 255)	// min옵션 이상
			unicode::_sprintf(szTempName, "%s +%d%s%s", szTempName, pMixRecipeItem->m_iOptionMin, GlobalText[2343], GlobalText[2341]);	// "옵션""이상"
		else
			unicode::_sprintf(szTempName, "%s +%d~%d%s", szTempName, pMixRecipeItem->m_iOptionMin, pMixRecipeItem->m_iOptionMax, GlobalText[2343]);	// "옵션"
	}
	// 아이템 개수
	if (pMixRecipeItem->m_iCountMin == 0 && pMixRecipeItem->m_iCountMax == 255)	// 모든 개수 가능
		unicode::_sprintf(szTempName, "%s (%s)", szTempName, GlobalText[2344]);	// "확률증가"
	else if (pMixRecipeItem->m_iCountMin == pMixRecipeItem->m_iCountMax)	// 일정 개수
		unicode::_sprintf(szTempName, "%s %d%s", szTempName, pMixRecipeItem->m_iCountMin, GlobalText[2345]);	// "개"
	else if (pMixRecipeItem->m_iCountMin == 0)	// max개수 이하
		unicode::_sprintf(szTempName, "%s %d%s %s", szTempName, pMixRecipeItem->m_iCountMax, GlobalText[2345], GlobalText[2342]);	// "개""이하"
	else if (pMixRecipeItem->m_iCountMax == 255)	// min개수 이상
		unicode::_sprintf(szTempName, "%s %d%s %s", szTempName, pMixRecipeItem->m_iCountMin, GlobalText[2345], GlobalText[2341]);	// "개""이상"
	else
		unicode::_sprintf(szTempName, "%s %d~%d%s", szTempName, pMixRecipeItem->m_iCountMin, pMixRecipeItem->m_iCountMax, GlobalText[2345]);	// "개"

	// 엑설런트+세트 접두어
	BOOL bPreName = FALSE;
	if (pMixRecipeItem->m_dwSpecialItem & RCP_SP_EXCELLENT)
	{
		unicode::_sprintf(pszNameOut, "%s %s", GlobalText[620], szTempName);	// 엑설런트
		bPreName = TRUE;
	}
	if (pMixRecipeItem->m_dwSpecialItem & RCP_SP_SETITEM)
	{
		unicode::_sprintf(pszNameOut, "%s %s", GlobalText[1089], szTempName);	// 세트
		bPreName = TRUE;
	}
	if (pMixRecipeItem->m_dwSpecialItem & RCP_SP_HARMONY)
	{
#ifdef SOCKET_SYSTEM
		unicode::_sprintf(pszNameOut, "%s %s", GlobalText[1550], szTempName);	// 강화된 아이템
#else	// SOCKET_SYSTEM
		unicode::_sprintf(pszNameOut, "%s %s", GlobalText[2061], szTempName);	// 제련된 아이템
#endif	// SOCKET_SYSTEM
		bPreName = TRUE;
	}
#ifdef ADD_SOCKET_MIX
	if (pMixRecipeItem->m_dwSpecialItem & RCP_SP_SOCKETITEM)
	{
		unicode::_sprintf(pszNameOut, "%s %s", GlobalText[2650], szTempName);	// 소켓 아이템
		bPreName = TRUE;
	}
#endif	// ADD_SOCKET_MIX
	if (bPreName == FALSE)
	{
		unicode::_strcpy(pszNameOut ,szTempName);
	}

	if (g_MixRecipeMgr.IsMixInit())
	{
		if (pMixRecipeItem->m_iCountMin == 0) return MIX_SOURCE_PARTIALLY;
		else return MIX_SOURCE_NO;
	}

	if (m_iMostSimilarMixSourceTest[iItemNum] == 0)	// 재료 일치
		return MIX_SOURCE_YES;
	else if (m_iMostSimilarMixSourceTest[iItemNum] < pMixRecipeItem->m_iCountMax)	// 옵션 재료 일치 or 부분 일치
	{
		if (pMixRecipeItem->m_iCountMin <= 1) return MIX_SOURCE_YES;
		else return MIX_SOURCE_PARTIALLY;
	}
	else	// 재료 없음
	{
		if (pMixRecipeItem->m_iCountMin == 0) return MIX_SOURCE_PARTIALLY;
		else return MIX_SOURCE_NO;
	}
}

void CMixRecipes::EvaluateMixItems(int iNumMixItems, CMixItem * pMixItems)
{
	m_bFindMixLuckItem = FALSE;
	m_dwTotalItemValue = 0;
	m_dwExcellentItemValue = 0;
	m_dwEquipmentItemValue = 0;
	m_dwWingItemValue = 0;
	m_dwSetItemValue = 0;
#ifdef YDG_FIX_SOCKETSPHERE_MIXRATE
	m_dwTotalNonJewelItemValue = 0;
#endif	// YDG_FIX_SOCKETSPHERE_MIXRATE
	for (int i = 0; i < iNumMixItems; ++i)
	{
		if (pMixItems[i].m_bMixLuck == TRUE) m_bFindMixLuckItem = TRUE;	// 행운 옵션 확인
		if (pMixItems[i].m_dwSpecialItem & RCP_SP_EXCELLENT) m_dwExcellentItemValue += pMixItems[i].m_dwMixValue;	// 엑템가격
		if (pMixItems[i].m_bIsEquipment == TRUE) m_dwEquipmentItemValue += pMixItems[i].m_dwMixValue;	// 무기/방어구 가격
		if (pMixItems[i].m_bIsWing == TRUE) m_dwWingItemValue += pMixItems[i].m_dwMixValue;	// 날개 가격
		if (pMixItems[i].m_dwSpecialItem & RCP_SP_SETITEM) m_dwSetItemValue += pMixItems[i].m_dwMixValue;	// 세트아이템 가격
#ifdef YDG_FIX_SOCKETSPHERE_MIXRATE
		if (pMixItems[i].m_bIsJewelItem == FALSE) m_dwTotalNonJewelItemValue += pMixItems[i].m_dwMixValue;	// 보석아닌 아이템 전체 가격
#endif	// YDG_FIX_SOCKETSPHERE_MIXRATE
		m_dwTotalItemValue += pMixItems[i].m_dwMixValue;	// 전체 가격
	}
}

void CMixRecipes::CalcCharmBonusRate(int iNumMixItems, CMixItem * pMixItems)
{
	m_wTotalCharmBonus = 0;
	for (int i = 0; i < iNumMixItems; ++i)
	{
		if (pMixItems[i].m_bIsCharmItem == TRUE) m_wTotalCharmBonus += pMixItems[i].m_iCount;	// 행운의 부적 확률 합
	}
}

#ifdef PSW_ADD_MIX_CHAOSCHARM
void CMixRecipes::CalcChaosCharmCount(int iNumMixItems, CMixItem * pMixItems)
{
	m_wTotalChaosCharmCount = 0;
	for (int i = 0; i < iNumMixItems; ++i)
	{
		if (pMixItems[i].m_bIsChaosCharmItem == TRUE) m_wTotalChaosCharmCount += 1;
	}
}
#endif //PSW_ADD_MIX_CHAOSCHARM

// 조합시 성공 확률 계산
void CMixRecipes::CalcMixRate(int iNumMixItems, CMixItem * pMixItems)
{
#ifdef KWAK_FIX_COMPILE_LEVEL4_WARNING
	if(iNumMixItems < 0)	return;
	if(pMixItems == NULL)	return;
#endif // KWAK_FIX_COMPILE_LEVEL4_WARNING
	m_iSuccessRate = 0;
	if (GetCurRecipe() == NULL) return;

	m_pMixRates = GetCurRecipe()->m_RateToken;
	m_iMixRateIter = 0;
	m_iSuccessRate = (int)MixrateAddSub();

	if (m_iSuccessRate > GetCurRecipe()->m_iSuccessRate)
	{
		m_iSuccessRate = GetCurRecipe()->m_iSuccessRate;	// 최대확률
	}
	if (GetCurRecipe()->m_bCharmOption == 'A')	// 행운의 부적
	{
		m_iSuccessRate += m_wTotalCharmBonus;
	}
	if (m_iSuccessRate > 100)
	{
		m_iSuccessRate = 100;
	}
}

float CMixRecipes::MixrateAddSub()
{
	float fLvalue = 0;
	while(1)
	{
		if (m_iMixRateIter >= GetCurRecipe()->m_iNumRateData || m_pMixRates[m_iMixRateIter].op == MRCP_RP)	// 수식의 끝, 닫는 괄호
		{
			return fLvalue;
		}
		switch(m_pMixRates[m_iMixRateIter].op)
		{
		case MRCP_ADD:
			++m_iMixRateIter;
			fLvalue += MixrateMulDiv();
			break;
		case MRCP_SUB:
 			++m_iMixRateIter;
			fLvalue -= MixrateMulDiv();
			break;
		default:
			fLvalue = MixrateMulDiv();	// 수식의 첫항
			break;
		};
	}
}

float CMixRecipes::MixrateMulDiv()
{
	float fLvalue = 0;
	while(1)
	{
		if (m_iMixRateIter >= GetCurRecipe()->m_iNumRateData || m_pMixRates[m_iMixRateIter].op == MRCP_RP)	// 수식의 끝, 닫는 괄호
		{
			return fLvalue;
		}
		switch(m_pMixRates[m_iMixRateIter].op)
		{
		case MRCP_ADD:
		case MRCP_SUB:
			return fLvalue;
		case MRCP_MUL:
 			++m_iMixRateIter;
			fLvalue *= MixrateFactor();
 			break;
		case MRCP_DIV:
			++m_iMixRateIter;
			fLvalue /= MixrateFactor();
 			break;
		default:
			fLvalue = MixrateFactor();	// 수식의 첫항
 			break;
		};
	}
}

float CMixRecipes::MixrateFactor()
{
	float fValue = 0;
	switch(m_pMixRates[m_iMixRateIter].op)
	{
	case MRCP_LP:
		++m_iMixRateIter;
		fValue = MixrateAddSub();
		break;
	case MRCP_INT:
		++m_iMixRateIter;
		if (m_pMixRates[m_iMixRateIter].op != MRCP_LP) assert(!"문법에러");
		++m_iMixRateIter;	// ( 스킵
		fValue = int(MixrateAddSub());
		break;
	case MRCP_NUMBER:
		fValue = (float)m_pMixRates[m_iMixRateIter].value;	// 상수 값
		break;
	case MRCP_MAXRATE:	// 스크립트의 최대 확률
		fValue = GetCurRecipe()->m_iSuccessRate;
		break;
	case MRCP_ITEM:			// 조합창 아이템 가격 총합
		fValue = m_dwTotalItemValue;
		break;
	case MRCP_WING:			// 조합창 날개 가격 총합
		fValue = m_dwWingItemValue;
		break;
	case MRCP_EXCELLENT:		// 조합창 엑템 가격 총합
		fValue = m_dwExcellentItemValue;
		break;
	case MRCP_EQUIP:			// 조합창 무기+방어구 가격 총합
		fValue = m_dwEquipmentItemValue;
		break;
	case MRCP_SET:			// 조합창 세트아이템 가격 총합
		fValue = m_dwSetItemValue;
		break;
	case MRCP_LUCKOPT:		// 아이템의 행운 옵션 보너스 값
		if (m_bFindMixLuckItem) fValue = 25;
		else fValue = 0;
		break;
	case MRCP_LEVEL1:		// 조합 조건 첫번째 아이템의 레벨 (1~13)
		fValue = m_iFirstItemLevel;
		break;
#ifdef YDG_FIX_SOCKETSPHERE_MIXRATE
	case MRCP_NONJEWELITEM:	// 보석가격을 제외한 조합창 아이템 가격 총합 (축,영,혼,창,생,조,수,석묶음)
		fValue = m_dwTotalNonJewelItemValue;
		break;
#endif	// YDG_FIX_SOCKETSPHERE_MIXRATE
	}
	++m_iMixRateIter;
	return fValue;
}

void CMixRecipes::CalcMixReqZen(int iNumMixItems, CMixItem * pMixItems)
{
#ifdef KWAK_FIX_COMPILE_LEVEL4_WARNING
	if(iNumMixItems < 0)	return;
	if(pMixItems == NULL)	return;
#endif // KWAK_FIX_COMPILE_LEVEL4_WARNING
	// 조합시 필요 젠
	//	필요 젠 타입 A: [고정 금액]
	//	필요 젠 타입 B: [확률] * 10,000젠
	//	필요 젠 타입 C: [고정 금액] (물약당 금액)
	//	필요 젠 타입 D: [제련레벨에 따라 제련아이템 환원 테이블 이용]
	m_dwRequiredZen = 0;
	if (GetCurRecipe() == NULL) return;
	switch(GetCurRecipe()->m_bRequiredZenType)
	{
	case 'A':
	case 'C':	// 출력시에 물약당 가격으로 표시
		m_dwRequiredZen = GetCurRecipe()->m_dwRequiredZen;
		break;
	case 'B':
		m_dwRequiredZen = m_iSuccessRate * GetCurRecipe()->m_dwRequiredZen;
		break;
	case 'D':
		{
			// 조화의 보석 제련 아이템 환원 가격 얻어내기
			int iItemType = 0;
			if( ITEM_SWORD <= pMixItems[0].m_sType && ITEM_STAFF > pMixItems[0].m_sType )
			{
				iItemType = SI_Weapon;
			}
			else if( ITEM_STAFF <= pMixItems[0].m_sType && ITEM_SHIELD > pMixItems[0].m_sType )
			{
				iItemType = SI_Staff;
			}
			else if( ITEM_SHIELD <= pMixItems[0].m_sType && ITEM_WING > pMixItems[0].m_sType )
			{
				iItemType = SI_Defense;
			}
			m_dwRequiredZen = g_pUIJewelHarmonyinfo->GetHarmonyJewelOptionInfo(iItemType,
				pMixItems[0].m_wHarmonyOption ).Zen[pMixItems[0].m_wHarmonyOptionLevel];
		}
		break;
	default:
		break;
	}
}

// 조합옵션 조건 검사용
BOOL CMixRecipes::IsChaosItem(CMixItem & rSource)
{
	if (rSource.m_sType == ITEM_MACE+6 || rSource.m_sType == ITEM_BOW+6 || rSource.m_sType == ITEM_STAFF+7) return TRUE;
	return FALSE;
}

BOOL CMixRecipes::IsChaosJewel(CMixItem & rSource)
{
	if (rSource.m_sType == ITEM_WING+15) return TRUE;
	return FALSE;
}

BOOL CMixRecipes::Is380AddedItem(CMixItem & rSource)
{
	return rSource.m_b380AddedItem;
}

BOOL CMixRecipes::IsFenrirAddedItem(CMixItem & rSource)
{
	return rSource.m_bFenrirAddedItem;
}

BOOL CMixRecipes::IsUpgradableItem(CMixItem & rSource)
{
	return (rSource.m_bIsEquipment || rSource.m_bIsWing || rSource.m_bIsUpgradedWing || rSource.m_bIs3rdUpgradedWing);
}

BOOL CMixRecipes::IsSourceOfRefiningStone(CMixItem & rSource)
{
	if (rSource.m_iLevel < 4)
	{
		switch(rSource.m_sType)
		{
		case ITEM_SWORD+0: case ITEM_SWORD+1: case ITEM_SWORD+2: case ITEM_SWORD+4:
		case ITEM_AXE+0: case ITEM_AXE+1: case ITEM_AXE+2:
		case ITEM_MACE+0: case ITEM_MACE+1: case ITEM_MACE+2:
		case ITEM_SPEAR+1: case ITEM_SPEAR+2: case ITEM_SPEAR+3: case ITEM_SPEAR+5: case ITEM_SPEAR+6:
		case ITEM_BOW+0: case ITEM_BOW+1: case ITEM_BOW+2: case ITEM_BOW+3:
		case ITEM_BOW+8: case ITEM_BOW+9: case ITEM_BOW+10: case ITEM_BOW+11:
		case ITEM_STAFF+0: case ITEM_STAFF+1: case ITEM_STAFF+2:
		case ITEM_SHIELD+0: case ITEM_SHIELD+1: case ITEM_SHIELD+2: case ITEM_SHIELD+3: case ITEM_SHIELD+4:
		case ITEM_SHIELD+6: case ITEM_SHIELD+7: case ITEM_SHIELD+9: case ITEM_SHIELD+10:
		case ITEM_HELM+0: case ITEM_HELM+2: case ITEM_HELM+4: case ITEM_HELM+5: case ITEM_HELM+6:
		case ITEM_HELM+7: case ITEM_HELM+8: case ITEM_HELM+10: case ITEM_HELM+11: case ITEM_HELM+12:
		case ITEM_ARMOR+0: case ITEM_ARMOR+2: case ITEM_ARMOR+4: case ITEM_ARMOR+5: case ITEM_ARMOR+6:
		case ITEM_ARMOR+7: case ITEM_ARMOR+8: case ITEM_ARMOR+10: case ITEM_ARMOR+11: case ITEM_ARMOR+12:
		case ITEM_PANTS+0: case ITEM_PANTS+2: case ITEM_PANTS+4: case ITEM_PANTS+5: case ITEM_PANTS+6:
		case ITEM_PANTS+7: case ITEM_PANTS+8: case ITEM_PANTS+10: case ITEM_PANTS+11: case ITEM_PANTS+12:
		case ITEM_GLOVES+0: case ITEM_GLOVES+2: case ITEM_GLOVES+4: case ITEM_GLOVES+5: case ITEM_GLOVES+6:
		case ITEM_GLOVES+7: case ITEM_GLOVES+8: case ITEM_GLOVES+10: case ITEM_GLOVES+11: case ITEM_GLOVES+12:
		case ITEM_BOOTS+0: case ITEM_BOOTS+2: case ITEM_BOOTS+4: case ITEM_BOOTS+5: case ITEM_BOOTS+6:
		case ITEM_BOOTS+7: case ITEM_BOOTS+8: case ITEM_BOOTS+10: case ITEM_BOOTS+11: case ITEM_BOOTS+12:
			return FALSE;
		}
	}
	return TRUE;
}

#ifdef YDG_FIX_SOCKET_ATTACH_CONDITION
BOOL CMixRecipes::IsSourceOfAttachSeedSphereToWeapon(CMixItem & rSource)
{
	if (rSource.m_sType >= ITEM_WING+100 && rSource.m_sType <= ITEM_WING+129)
	{
		int iSeedSphereType = rSource.m_sType - ITEM_WING;

		// 불 얼음 번개 속성은 ITEM_WING+100, 102 등 짝수인덱스이다
		if (iSeedSphereType % 2 == 0) return TRUE;
	}
	return FALSE;
}

BOOL CMixRecipes::IsSourceOfAttachSeedSphereToArmor(CMixItem & rSource)
{
	if (rSource.m_sType >= ITEM_WING+100 && rSource.m_sType <= ITEM_WING+129)
	{
		int iSeedSphereType = rSource.m_sType - ITEM_WING;

		// 물 바람 땅 속성은 ITEM_WING+101, 103 등 홀수인덱스이다
		if (iSeedSphereType % 2 == 1) return TRUE;
	}
	return FALSE;
}
#endif	// YDG_FIX_SOCKET_ATTACH_CONDITION

BOOL CMixRecipes::IsCharmItem(CMixItem & rSource)
{
	return rSource.m_bIsCharmItem;
}

#ifdef PSW_ADD_MIX_CHAOSCHARM
BOOL CMixRecipes::IsChaosCharmItem(CMixItem & rSource)
{
	return rSource.m_bIsChaosCharmItem;
}
#endif //PSW_ADD_MIX_CHAOSCHARM

#ifdef YDG_FIX_SOCKETSPHERE_MIXRATE
BOOL CMixRecipes::IsJewelItem(CMixItem & rSource)
{
	return rSource.m_bIsJewelItem;
}
#endif	// YDG_FIX_SOCKETSPHERE_MIXRATE

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void CMixRecipeMgr::OpenRecipeFile(const unicode::t_char * szFileName)	// mix.bmd를 읽어들인다.
{
	int i, j;
	for (j = 0; j < MAX_MIX_TYPES; ++j)
	{
		m_MixRecipe[j].Reset();
	}

	FILE *fp = fopen(szFileName,"rb");
	if(fp == NULL)
	{
		unicode::t_char Text[256];
    	unicode::_sprintf(Text,"%s - File not exist.",szFileName);
		g_ErrorReport.Write( Text);
		MessageBox(g_hWnd,Text,NULL,MB_OK);
		SendMessage(g_hWnd,WM_DESTROY,0,0);
		exit(0);
	}

	int iNumMixRecipes[MAX_MIX_TYPES];
	int iSize = sizeof(int) * MAX_MIX_TYPES;
	fread(iNumMixRecipes, iSize, 1, fp);	// 총 조합 방법 수
	BuxConvert((BYTE*)iNumMixRecipes, iSize);

	iSize = sizeof(MIX_RECIPE);
	for (j = 0; j < MAX_MIX_TYPES; ++j)
	{
#ifdef SOCKET_SYSTEM
#ifdef LJH_MOD_EXTENDING_NUM_OF_MIX_RECIPES_FROM_100_TO_1000 
		if (feof(fp) || iNumMixRecipes[j] > 1000)
#else  //LJH_MOD_EXTENDING_NUM_OF_MIX_RECIPES_FROM_100_TO_1000
		if (feof(fp) || iNumMixRecipes[j] > 100)
#endif //LJH_MOD_EXTENDING_NUM_OF_MIX_RECIPES_FROM_100_TO_1000
		{
			//assert(!"이전버전의 mix.bmd입니다. 최신 mix.bmd가 맞는지 확인하세요!");
			unicode::t_char Text[256];
    		unicode::_sprintf(Text,"%s - Version not matched.",szFileName);
			g_ErrorReport.Write( Text);
			MessageBox(g_hWnd,Text,NULL,MB_OK);
			SendMessage(g_hWnd,WM_DESTROY,0,0);
			fclose(fp);
			exit(0);
		}
#endif	// SOCKET_SYSTEM
		for (i = 0; i < iNumMixRecipes[j]; ++i)
		{
			MIX_RECIPE * pMixRecipe = new MIX_RECIPE;
			fread(pMixRecipe, iSize, 1, fp);
			BuxConvert((BYTE*)pMixRecipe, iSize);
			m_MixRecipe[j].AddRecipe(pMixRecipe);
		}
	}
	fclose(fp);
}

int CMixRecipeMgr::GetMixInventoryType()
{
	assert(m_iMixType >= MIXTYPE_GOBLIN_NORMAL && m_iMixType < MAX_MIX_TYPES && "정의되지 않은 조합창");
	return m_iMixType;
}

int CMixRecipeMgr::GetMixInventoryEquipmentIndex()
{
	switch(GetMixInventoryType())
	{
	case SEASON3A::MIXTYPE_GOBLIN_NORMAL:
	case SEASON3A::MIXTYPE_GOBLIN_CHAOSITEM:
	case SEASON3A::MIXTYPE_GOBLIN_ADD380:
		return REQUEST_EQUIPMENT_CHAOS_MIX;
	case SEASON3A::MIXTYPE_CASTLE_SENIOR:
		return REQUEST_EQUIPMENT_CHAOS_MIX;
	case SEASON3A::MIXTYPE_TRAINER:
		return REQUEST_EQUIPMENT_TRAINER_MIX;
	case SEASON3A::MIXTYPE_OSBOURNE:
		return REQUEST_EQUIPMENT_OSBOURNE_MIX;
	case SEASON3A::MIXTYPE_JERRIDON:
		return REQUEST_EQUIPMENT_JERRIDON_MIX;
	case SEASON3A::MIXTYPE_ELPIS:
		return REQUEST_EQUIPMENT_ELPIS_MIX;
#ifdef ADD_GLOBAL_MIX_MAR08
	case SEASON3A::MIXTYPE_CHAOS_CARD:
		return REQUEST_EQUIPMENT_CHAOS_CARD_MIX;
	case SEASON3A::MIXTYPE_CHERRYBLOSSOM:
		return REQUEST_EQUIPMENT_CHERRYBLOSSOM_MIX;
#endif //ADD_GLOBAL_MIX_MAR08
#ifdef ADD_SOCKET_MIX
	case SEASON3A::MIXTYPE_EXTRACT_SEED:
		return REQUEST_EQUIPMENT_EXTRACT_SEED_MIX;
	case SEASON3A::MIXTYPE_SEED_SPHERE:
		return REQUEST_EQUIPMENT_SEED_SPHERE_MIX;
	case SEASON3A::MIXTYPE_ATTACH_SOCKET:
		return REQUEST_EQUIPMENT_ATTACH_SOCKET_MIX;
	case SEASON3A::MIXTYPE_DETACH_SOCKET:
		return REQUEST_EQUIPMENT_DETACH_SOCKET_MIX;
#endif	// ADD_SOCKET_MIX
	default:
		assert(!"정의되지 않은 조합 창");
		return REQUEST_EQUIPMENT_CHAOS_MIX;
	}
}

void CMixRecipeMgr::ResetMixItemInventory()
{
	m_MixItemInventory.Reset();
}

void CMixRecipeMgr::AddItemToMixItemInventory(ITEM * pItem)
{
	m_MixItemInventory.AddItem(pItem);
}

void CMixRecipeMgr::CheckMixInventory()
{
	if (m_MixItemInventory.GetNumMixItems() == 0) m_bIsMixInit = TRUE;
	else m_bIsMixInit = FALSE;

	// 조합 조건과 비교한다.
	CheckRecipe(m_MixItemInventory.GetNumMixItems(), m_MixItemInventory.GetMixItems());
	CheckRecipeSimilarity(m_MixItemInventory.GetNumMixItems(), m_MixItemInventory.GetMixItems());
}

#ifdef ADD_SOCKET_MIX
int CMixRecipeMgr::GetSeedSphereID(int iOrder)
{
	int iCurrOrder = 0;
	CMixItem * pItems = m_MixItemInventory.GetMixItems();
	for (int i = 0; i < m_MixItemInventory.GetNumMixItems(); ++i)
	{
		if (pItems[i].m_bySeedSphereID != SOCKET_EMPTY)	// 시드스피어다
		{
			if (iCurrOrder == iOrder)
			{
				return pItems[i].m_bySeedSphereID;
			}
			else
			{
				++iCurrOrder;
			}
		}
	}
	return SOCKET_EMPTY;
}
#endif	// ADD_SOCKET_MIX
